import { Inject, Injectable, UnauthorizedException } from '@nestjs/common';
import { VerifyAuthMessageDto } from '@/routes/auth/entities/schemas/verify-auth-message.dto';
import { IAuthRepository } from '@/domain/auth/auth.repository.interface';
import { IJwtService } from '@/datasources/jwt/jwt.service.interface';

@Injectable()
export class AuthService {
  static readonly AUTH_TOKEN_TOKEN_TYPE = 'Bearer';

  constructor(
    @Inject(IAuthRepository)
    private readonly authRepository: IAuthRepository,
    @Inject(IJwtService)
    private readonly jwtService: IJwtService,
  ) {}

  async getNonce(): Promise<{
    nonce: string;
  }> {
    return await this.authRepository.generateNonce();
  }

  /**
   * Verifies the validity of a signed message and returns an access token:
   *
   * 1. Ensure the message itself has not expired.
   * 2. Ensure the nonce was generated by us/is not a replay attack.
   * 3. Verify the signature of the message.
   * 4. Return an access token if all checks pass.
   *
   * @param args.request - Express request object.
   * @param args.verifyAuthMessageDto - DTO containing the message and signature to verify.
   *
   * The following adhere to JWT standard {@link https://datatracker.ietf.org/doc/html/rfc7519}
   *
   * @returns accessToken - JWT access token
   * @returns tokenType - token type ('Bearer') to be used in the `Authorization` header
   * @returns notBefore - epoch from when token is valid (if applicable, otherwise null)
   * @returns expiresIn - time in seconds until the token expires (if applicable, otherwise null)
   */
  async verify(args: VerifyAuthMessageDto): Promise<{
    accessToken: string;
    tokenType: string;
    notBefore: number | null;
    expiresIn: number | null;
  }> {
    const isAuthorized = await this.authRepository
      .isAuthorized(args)
      .catch(() => false);

    if (!isAuthorized) {
      throw new UnauthorizedException();
    }

    const dateWhenTokenIsValid = args.message.notBefore
      ? new Date(args.message.notBefore)
      : null;
    const dateWhenTokenExpires = args.message.expirationTime
      ? new Date(args.message.expirationTime)
      : null;

    const secondsUntilTokenIsValid = dateWhenTokenIsValid
      ? this.getSecondsUntil(dateWhenTokenIsValid)
      : null;
    const secondsUntilTokenExpires = dateWhenTokenExpires
      ? this.getSecondsUntil(dateWhenTokenExpires)
      : null;

    const accessToken = this.jwtService.sign(args.message, {
      ...(secondsUntilTokenIsValid !== null && {
        notBefore: secondsUntilTokenIsValid,
      }),
      ...(secondsUntilTokenExpires !== null && {
        expiresIn: secondsUntilTokenExpires,
      }),
    });

    return {
      tokenType: AuthService.AUTH_TOKEN_TOKEN_TYPE,
      accessToken,
      notBefore: dateWhenTokenIsValid?.getTime() ?? null,
      expiresIn: secondsUntilTokenExpires,
    };
  }

  private getSecondsUntil(date: Date): number {
    return Math.floor((date.getTime() - Date.now()) / 1_000);
  }
}
