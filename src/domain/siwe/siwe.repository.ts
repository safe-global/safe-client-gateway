import { ISiweApi } from '@/domain/interfaces/siwe-api.interface';
import { ISiweRepository } from '@/domain/siwe/siwe.repository.interface';
import { VerifyAuthMessageDto } from '@/routes/auth/entities/verify-auth-message.dto.entity';
import { Inject, Injectable } from '@nestjs/common';

@Injectable()
export class SiweRepository implements ISiweRepository {
  constructor(
    @Inject(ISiweApi)
    private readonly siweApi: ISiweApi,
  ) {}

  /**
   * Generates a unique nonce and stores it in cache for later verification.
   *
   * @returns nonce - unique string to be signed
   */
  async generateNonce(): Promise<{ nonce: string }> {
    const nonce = this.siweApi.generateNonce();

    // Store nonce for reference to verify/prevent replay attacks
    await this.siweApi.storeNonce(nonce);

    return {
      nonce,
    };
  }

  /**
   * Verifies the validity of a signed message:
   *
   * 1. Ensure the message itself has not expired.
   * 2. Ensure the nonce was generated by us/is not a replay attack.
   * 3. Verify the signature of the message.
   *
   * @param args - DTO containing the message and signature to verify.
   *
   * @returns boolean - whether the signed message is valid.
   */
  async isValidMessage(args: VerifyAuthMessageDto): Promise<boolean> {
    const isExpired =
      !!args.message.expirationTime &&
      new Date(args.message.expirationTime) < new Date();

    try {
      // Verification is not necessary, message has expired
      if (isExpired) {
        return false;
      }

      const [isValidSignature, storedNonce] = await Promise.all([
        this.siweApi.verifyMessage(args),
        this.siweApi.getNonce(args.message.nonce),
      ]);
      const isValidNonce = storedNonce === args.message.nonce;

      return isValidSignature && isValidNonce;
    } catch {
      return false;
    } finally {
      await this.siweApi.clearNonce(args.message.nonce);
    }
  }
}
