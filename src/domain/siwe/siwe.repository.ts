import { IConfigurationService } from '@/config/configuration.service.interface';
import { CacheRouter } from '@/datasources/cache/cache.router';
import {
  CacheService,
  ICacheService,
} from '@/datasources/cache/cache.service.interface';
import { IAuthApi } from '@/domain/interfaces/auth-api.interface';
import { ISiweRepository } from '@/domain/siwe/siwe.repository.interface';
import { VerifyAuthMessageDto } from '@/routes/auth/entities/verify-auth-message.dto.entity';
import { Inject, Injectable } from '@nestjs/common';

@Injectable()
export class SiweRepository implements ISiweRepository {
  private readonly nonceTtlInSeconds: number;

  constructor(
    @Inject(IAuthApi)
    private readonly authApi: IAuthApi,
    @Inject(IConfigurationService)
    private readonly configurationService: IConfigurationService,
    @Inject(CacheService) private readonly cacheService: ICacheService,
  ) {
    this.nonceTtlInSeconds = this.configurationService.getOrThrow(
      'auth.nonceTtlSeconds',
    );
  }

  /**
   * Generates a unique nonce and stores it in cache for later verification.
   *
   * @returns nonce - unique string to be signed
   */
  async generateNonce(): Promise<{ nonce: string }> {
    const nonce = this.authApi.generateNonce();

    // Store nonce for reference to verify/prevent replay attacks
    const cacheDir = CacheRouter.getAuthNonceCacheDir(nonce);
    await this.cacheService.set(cacheDir, nonce, this.nonceTtlInSeconds);

    return {
      nonce,
    };
  }

  /**
   * Verifies the validity of a signed message:
   *
   * 1. Ensure the message itself has not expired.
   * 2. Ensure the nonce was generated by us/is not a replay attack.
   * 3. Verify the signature of the message.
   *
   * @param args - DTO containing the message and signature to verify.
   *
   * @returns boolean - whether the signed message is valid.
   */
  async isValidMessage(args: VerifyAuthMessageDto): Promise<boolean> {
    const cacheDir = CacheRouter.getAuthNonceCacheDir(args.message.nonce);

    const isExpired =
      !!args.message.expirationTime &&
      new Date(args.message.expirationTime) < new Date();

    try {
      // Verification is not necessary, message has expired
      if (isExpired) {
        return false;
      }

      const [isValidSignature, cachedNonce] = await Promise.all([
        this.authApi.verifyMessage(args),
        this.cacheService.get(cacheDir),
      ]);
      const isValidNonce = cachedNonce === args.message.nonce;

      return isValidSignature && isValidNonce;
    } catch {
      return false;
    } finally {
      await this.cacheService.deleteByKey(cacheDir.key);
    }
  }
}
