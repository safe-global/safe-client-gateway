import { IConfigurationService } from '@/config/configuration.service.interface';
import { CacheRouter } from '@/datasources/cache/cache.router';
import {
  CacheService,
  ICacheService,
} from '@/datasources/cache/cache.service.interface';
import { ISiweRepository } from '@/domain/siwe/siwe.repository.interface';
import { LoggingService, ILoggingService } from '@/logging/logging.interface';
import { Inject, Injectable } from '@nestjs/common';
import { verifyMessage } from 'viem';
import {
  generateSiweNonce,
  parseSiweMessage,
  validateSiweMessage,
} from 'viem/siwe';

@Injectable()
export class SiweRepository implements ISiweRepository {
  private readonly nonceTtlInSeconds: number;
  private readonly maxValidityPeriodInSeconds: number;

  constructor(
    @Inject(IConfigurationService)
    private readonly configurationService: IConfigurationService,
    @Inject(LoggingService)
    private readonly loggingService: ILoggingService,
    @Inject(CacheService) private readonly cacheService: ICacheService,
  ) {
    this.nonceTtlInSeconds = this.configurationService.getOrThrow(
      'auth.nonceTtlSeconds',
    );
    this.maxValidityPeriodInSeconds = this.configurationService.getOrThrow(
      'auth.maxValidityPeriodSeconds',
    );
  }

  /**
   * Generates a unique nonce and stores it in cache for later verification.
   *
   * @returns nonce - unique string to be signed
   */
  async generateNonce(): Promise<{ nonce: string }> {
    const nonce = generateSiweNonce();

    const cacheDir = CacheRouter.getAuthNonceCacheDir(nonce);
    await this.cacheService.set(cacheDir, nonce, this.nonceTtlInSeconds);

    return {
      nonce,
    };
  }

  /**
   * Verifies the validity of a signed message:
   *
   * 1. Ensure the message itself is not before or after validity period.
   * 2. Ensure the desired expiration time is within the max validity period.
   * 3. Verify the signature.
   * 4. Ensure the nonce was generated by us/is not a replay attack.
   *
   * @param args.message - SiWe message
   * @param args.signature - signature from signing {@link args.message}
   *
   * @returns boolean - whether the signed message is valid
   */
  async verifyMessage(args: {
    message: string;
    signature: `0x${string}`;
  }): Promise<boolean> {
    const message = parseSiweMessage(args.message);

    // Without nonce we can't verify whether a replay attack
    if (!message.nonce) {
      return false;
    }

    const cacheDir = CacheRouter.getAuthNonceCacheDir(message.nonce);

    try {
      // Verifying message after notBefore and before expirationTime
      const isValidMessage = validateSiweMessage({
        message,
      });

      if (!isValidMessage || !message.address) {
        return false;
      }

      // Expiration expectation does not exceed max validity period
      const isExpirationValid =
        !message.expirationTime ||
        message.expirationTime <=
          new Date(Date.now() + this.maxValidityPeriodInSeconds * 1_000);

      if (!isExpirationValid) {
        return false;
      }

      // Verify signature and nonce is cached (not a replay attack)
      const [isValidSignature, isNonceCached] = await Promise.all([
        verifyMessage({
          address: message.address,
          message: args.message,
          signature: args.signature,
        }),
        this.cacheService.get(cacheDir).then(Boolean),
      ]);

      return isValidSignature && isNonceCached;
    } catch (e) {
      this.loggingService.debug(
        `Failed to verify SiWe message. message=${args.message}, error=${e}`,
      );
      return false;
    } finally {
      await this.cacheService.deleteByKey(cacheDir.key);
    }
  }
}
